<!doctype html>
<html>
<head>
  <style>
    body {
      display: flex;
      margin: 0;
      flex-direction: column;
    }
  </style>
</head>
<body>
  <canvas id=canvas></canvas>
  <script src="js/keycode.js"></script>
  <script src="js/three.js"></script>
  <script src="js/vr-display.js"></script>
  <script src="js/skin.js"></script>
  <script src="js/OBJLoader.js"></script>
  <script src="js/sprite3d.js"></script>
  <script src="../js/xrmp.js"></script>
  <script src="../js/xrmp-three.js"></script>
  <script>
    const canvas = document.getElementById('canvas');

    const getQueryVariable = variable => {
      const query = window.location.search.substring(1);
      const vars = query.split('&');
      for (let i = 0; i < vars.length; i++) {
        const pair = vars[i].split('=');
        if (decodeURIComponent(pair[0]) == variable) {
          return decodeURIComponent(pair[1]);
        }
      }
      return null;
    };
    const _makeId = () => Math.random().toString(36).substring(7);
    const _debounce = fn => {
      let running = false;
      let queued = false;

      const _go = () => {
        if (!running) {
          running = true;

          fn(() => {
            running = false;

            if (queued) {
              queued = false;

              _go();
            }
          });
        } else {
          queued = true;
        }
      };
      return _go;
    };
    const _decomposeObjectMatrixWorld = object => _decomposeMatrix(object.matrixWorld);
    const _decomposeMatrix = matrix => {
      const position = new THREE.Vector3();
      const rotation = new THREE.Quaternion();
      const scale = new THREE.Vector3();
      matrix.decompose(position, rotation, scale);
      return {position, rotation, scale};
    };
    const _requestSpriteMesh = () => new Promise((accept, reject) => {
      const img = new Image();
      const item = ITEMS[Math.floor(Math.random() * ITEMS.length)];
      img.src = `img/items/${item}.png`;
      img.onload = () => {
        const spriteMesh = sprite3d.makeSpriteMesh(img);
        accept(spriteMesh);
      };
      img.onerror = err => {
        reject(err);
      };
    });

    const SIDES = ['left', 'right'];
    const FLOOR_SIZE = 20;
    const ITEMS = [
      'apple',
      'axe',
      'blank',
      'bow',
      'chest',
      'coal',
      'craftingtable',
      'crd',
      'drone',
      'file',
      'firework',
      'flintsteel',
      'gun',
      'hammer',
      'hide',
      'iron',
      'lightsaber',
      'map',
      'meat',
      'mirror',
      'paper',
      'pickaxe',
      'sand',
      'skin',
      // 'space',
      'stick',
      'stone',
      'sword',
      'torch',
      'wood',
    ];
    const BAG_Y_OFFSET = -0.5;
    const BAG_Z_OFFSET = -0.05;

    (() => {
      const graphImg = new Image();
      graphImg.src = 'img/textures/graphy.png';
      graphImg.crossOrigin = 'Anonymous';
      graphImg.onload = () => {
        const floorMesh = (() => {
          const geometry = new THREE.PlaneBufferGeometry(FLOOR_SIZE, FLOOR_SIZE)
            .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(
              new THREE.Quaternion().setFromUnitVectors(
                new THREE.Vector3(0, 0, 1),
                new THREE.Vector3(0, 1, 0)
              )
            ));
          const uvs = geometry.attributes.uv.array;
          const numUvs = uvs.length / 2;
          for (let i = 0; i < numUvs; i++) {
            uvs[i * 2 + 0] *= FLOOR_SIZE / 10 * 2;
            uvs[i * 2 + 1] *= FLOOR_SIZE / 10;
          }

          const texture = new THREE.Texture(
            graphImg,
            THREE.UVMapping,
            THREE.RepeatWrapping,
            THREE.RepeatWrapping,
            THREE.NearestFilter,
            THREE.NearestFilter,
            THREE.RGBAFormat,
            THREE.UnsignedByteType,
            1
          );
          texture.needsUpdate = true;
          const material = new THREE.MeshBasicMaterial({
            map: texture,
            side: THREE.DoubleSide,
          });
          const mesh = new THREE.Mesh(geometry, material);
          return mesh;
        })();
        scene.add(floorMesh);
      };
      graphImg.onerror = err => {
        console.warn(err.stack);
      };
    })();

    const zeroVector = new THREE.Vector3(0, 0, 0);
    const zeroQuaternion = new THREE.Quaternion();
    const oneVector = new THREE.Vector3(1, 1, 1);
    const upVector = new THREE.Vector3(0, 1, 0);
    const armQuaternionOffset = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, -1, 0), new THREE.Vector3(0, 0, -1));

    const localVector = new THREE.Vector3();
    const localVector2 = new THREE.Vector3();
    const localVector3 = new THREE.Vector3();
    const localVector4 = new THREE.Vector3();
    const localVector5 = new THREE.Vector3();
    const localQuaternion = new THREE.Quaternion();
    const localEuler = new THREE.Euler();
    localEuler.order = 'YXZ';
    const localMatrix = new THREE.Matrix4();

    const camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.1, 10 * 1024);
    camera.position.set(0, 1, 1);
    camera.rotation.order = 'YXZ';

    const fakeDisplay = window.navigator.createVRDisplay();
    fakeDisplay.setSize(window.innerWidth * window.devicePixelRatio, window.innerHeight * window.devicePixelRatio);
    fakeDisplay.position.copy(camera.position);
    fakeDisplay.quaternion.copy(camera.quaternion);
    fakeDisplay.update();
    fakeDisplay.requestPresent([{source: canvas}])
      .then(() => {
        renderer.vr.setDevice(fakeDisplay);
      });

    const _getGamepads = () => {
      if (fakeDisplay.isPresenting) {
        return fakeDisplay.gamepads;
      } else {
        return navigator.getGamepads();
      }
    };

    let voicechatEnabled = false;
    const mp = (() => {
      const url = getQueryVariable('m');
      if (url) {
        const xrmp = new XRMultiplayer(url);
        const xrmpThree = new XRMultiplayerTHREE(xrmp);
        xrmpThree.localPlayerMesh = null;
        xrmpThree.onsync = () => {
          camera.add(xrmpThree.getAudioListener());

          const localPlayerMesh = xrmpThree.createLocalPlayerMesh();
          xrmpThree.localPlayerMesh = localPlayerMesh;

          const objectMeshes = xrmpThree.getObjectMeshes();
          const size = 5;
          let i = 0;
          for (let z = 0; z < size; z++) {
            for (let x = 0; x < size; x++) {
              const objectMesh = objectMeshes.find(objectMesh => objectMesh.object.id === i);

              if (!objectMesh) {
                const objectMesh = mp.createObjectMesh(i);
                objectMesh.position.set(-1/2 + x/(size-1), 0.1, -1/2 + z/(size-1));
                objectMesh.needsUpdate = true;

                _requestSpriteMesh()
                  .then(spriteMesh => {
                    objectMesh.add(spriteMesh);
                  })
                  .catch(err => {
                    console.warn(err.stack);
                  });

                scene.add(objectMesh);

                i++;
              }
            }
          }
        };
        xrmpThree.onclose = () => {
          console.log('mp close');
        };
        xrmpThree.onerror = e => {
          console.warn('mp error', e.error);
        };
        xrmpThree.onplayerenter = playerMesh => {
          const skinMesh = _makeSkinMesh(playerMesh);
          playerMesh.add(skinMesh);

          scene.add(playerMesh);
        };
        xrmpThree.onplayerleave = playerMesh => {
          scene.remove(playerMesh);
        };
        xrmpThree.onobjectadd = objectMesh => {
          _requestSpriteMesh()
            .then(spriteMesh => {
              objectMesh.add(spriteMesh);
            })
            .catch(err => {
              console.warn(err.stack);
            });

          scene.add(objectMesh);
        };
        xrmpThree.onobjectremove = objectMesh => {
          scene.remove(objectMesh);
        };
        return xrmpThree;
      } else {
        return null;
      }
    })();
    const _isMpOpen = () => Boolean(mp && mp.localPlayerMesh);

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    const renderer = new THREE.WebGLRenderer({
      canvas,
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.sortObjects = false;
    renderer.vr.enabled = true;

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xFFFFFF);

    const ambientLight = new THREE.AmbientLight(0x808080);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xFFFFFF, 1);
    directionalLight.position.set(1, 1, 1);
    scene.add(directionalLight);

    const controllerMeshes = [null, null];
    const lastGrabbeds = [false, false];
    const grabbedObjects = [null, null];
    for (let i = 0; i < 2; i++) {
      const controllerMesh = new THREE.Object3D();
      controllerMesh.position.set(i === 0 ? -0.1 : 0.1, 1, 0.5);
      controllerMesh.quaternion.setFromUnitVectors(
        new THREE.Vector3(0, 0, -1),
        new THREE.Vector3(0, -1, -1)
      );

      scene.add(controllerMesh);
      controllerMeshes[i] = controllerMesh;
    }

    const controllerMeshLoader = new THREE.OBJLoader();
    controllerMeshLoader.setPath('models/obj/vive-controller/');
    controllerMeshLoader.load('vr_controller_vive_1_5.obj', object => {
      const textureLoader = new THREE.TextureLoader();
      textureLoader.setPath('models/obj/vive-controller/');

      const controllerMesh = object.children[0];
      controllerMesh.material.map = textureLoader.load('onepointfive_texture.png');
      controllerMesh.material.specularMap = textureLoader.load('onepointfive_spec.png');

      controllerMeshes[0].add(object.clone());
      controllerMeshes[1].add(object.clone());
    });

    const _makeSkinMesh = (() => {
      const hmdEuler = new THREE.Euler();
      const controllerPosition = new THREE.Vector3();
      const controllerQuaternion = new THREE.Quaternion();
      const playerEuler = new THREE.Euler();
      const meshWorldPosition = new THREE.Vector3();
      const meshEyeWorldPosition = new THREE.Vector3();
      const playerQuaternionInverse = new THREE.Quaternion();
      const headQuaternion = new THREE.Quaternion();
      const headQuaternionInverse = new THREE.Quaternion();
      const localUpVector = new THREE.Vector3();
      const armWorldPosition = new THREE.Vector3();
      const armQuaternion = new THREE.Quaternion();
      const armQuaternionInverse = new THREE.Quaternion();
      const rotationMatrix = new THREE.Matrix4();

      const _mod = (value, divisor) => {
        const n = value % divisor;
        return n < 0 ? (divisor + n) : n
      };
      const _angleDiff = (a, b) => _mod((b - a) + Math.PI, Math.PI * 2) - Math.PI;

      return playerMesh => {
        const mesh = skin({
          limbs: true,
        });

        const uniforms = THREE.UniformsUtils.clone(skin.SKIN_SHADER.uniforms);

        mesh.onBeforeRender = (function(onBeforeRender) {
          return function() {
            mesh.material.uniforms.headRotation.value.copy(uniforms.headRotation.value);
            mesh.material.uniforms.leftArmRotation.value.copy(uniforms.leftArmRotation.value);
            mesh.material.uniforms.rightArmRotation.value.copy(uniforms.rightArmRotation.value);
            mesh.material.uniforms.theta.value = uniforms.theta.value;
            mesh.material.uniforms.headVisible.value = uniforms.headVisible.value;
            mesh.material.uniforms.hit.value = uniforms.hit.value;

            onBeforeRender.apply(this, arguments);
          };
        })(mesh.onBeforeRender);

        playerMesh.onupdate = () => {
          hmdEuler.setFromQuaternion(playerMesh.hmd.quaternion, camera.rotation.order);
          playerEuler.setFromQuaternion(mesh.quaternion, camera.rotation.order);
          const angleDiff = _angleDiff(hmdEuler.y, playerEuler.y);
          const angleDiffAbs = Math.abs(angleDiff);
          if (angleDiffAbs > Math.PI / 2) {
            playerEuler.y += (angleDiffAbs - (Math.PI / 2)) * (angleDiff < 0 ? 1 : -1);
            mesh.quaternion.setFromEuler(playerEuler);
          }

          mesh.getWorldPosition(meshWorldPosition);
          mesh.eye.getWorldPosition(meshEyeWorldPosition);
          mesh.position.copy(playerMesh.hmd.position)
            .sub(meshEyeWorldPosition)
            .add(meshWorldPosition);

          playerQuaternionInverse.copy(mesh.quaternion).inverse();
          headQuaternion.copy(playerQuaternionInverse).multiply(playerMesh.hmd.quaternion);
          headQuaternionInverse.copy(headQuaternion).inverse();
          uniforms.headRotation.value.set(headQuaternionInverse.x, headQuaternionInverse.y, headQuaternionInverse.z, headQuaternionInverse.w);
          mesh.head.quaternion.copy(headQuaternion);
          mesh.updateMatrixWorld();

          for (let i = 0; i < 2; i++) {
            const side = SIDES[i];
            const armRotation = uniforms[side === 'left' ? 'leftArmRotation' : 'rightArmRotation'];

            if (playerMesh.gamepads[i].visible) {
              controllerPosition.copy(playerMesh.gamepads[i].position);
              controllerQuaternion.copy(playerMesh.gamepads[i].quaternion);
              localUpVector.copy(upVector).applyQuaternion(controllerQuaternion);

              mesh.arms[side].getWorldPosition(armWorldPosition);
              rotationMatrix.lookAt(
                armWorldPosition,
                controllerPosition,
                localUpVector
              );
              armQuaternion
                .setFromRotationMatrix(rotationMatrix)
                .multiply(armQuaternionOffset)
                .premultiply(playerQuaternionInverse);
              armQuaternionInverse.copy(armQuaternion).inverse();
              armRotation.value.set(armQuaternionInverse.x, armQuaternionInverse.y, armQuaternionInverse.z, armQuaternionInverse.w);
            } else {
              armRotation.value.set(0, 0, 0, 1);
            }
          }
        };

        const skinImg = new Image();
        skinImg.crossOrigin = 'Anonymous';
        skinImg.src = 'img/skins/male.png';
        skinImg.onload = () => {
          mesh.setImage(skinImg);
        };
        skinImg.onerror = err => {
          console.warn('skin image error', err.stack);
        };

        return mesh;
      };
    })();

    const _makeBagMesh = () => {
      const result = new THREE.Object3D();

      const lineGeometry = new THREE.CylinderBufferGeometry(0.001, 0.001, 0.1, 3, 1);
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(lineGeometry.attributes.position.array.length * 12);
      geometry.addAttribute('position', new THREE.BufferAttribute(positions, 3));
      // axis
      positions.set(
        lineGeometry.clone().applyMatrix(
          localMatrix.makeTranslation(-0.1/2, 0, -0.1/2)
        ).attributes.position.array,
        lineGeometry.attributes.position.array.length * 0
      );
      positions.set(
        lineGeometry.clone().applyMatrix(
          localMatrix.makeTranslation(0.1/2, 0, -0.1/2)
        ).attributes.position.array,
        lineGeometry.attributes.position.array.length * 1
      );
      positions.set(
        lineGeometry.clone().applyMatrix(
          localMatrix.makeTranslation(-0.1/2, 0, 0.1/2)
        ).attributes.position.array,
        lineGeometry.attributes.position.array.length * 2
      );
      positions.set(
        lineGeometry.clone().applyMatrix(
          localMatrix.makeTranslation(0.1/2, 0, 0.1/2)
        ).attributes.position.array,
        lineGeometry.attributes.position.array.length * 3
      );
      // axis
      positions.set(
        lineGeometry.clone()
          .applyMatrix(
            localMatrix.makeRotationFromQuaternion(localQuaternion.setFromAxisAngle(localVector.set(0, 0, 1), Math.PI/2))
          )
          .applyMatrix(
            localMatrix.makeTranslation(0, -0.1/2, -0.1/2)
          ).attributes.position.array,
        lineGeometry.attributes.position.array.length * 4
      );
      positions.set(
        lineGeometry.clone()
          .applyMatrix(
            localMatrix.makeRotationFromQuaternion(localQuaternion.setFromAxisAngle(localVector.set(0, 0, 1), Math.PI/2))
          )
          .applyMatrix(
            localMatrix.makeTranslation(0, -0.1/2, 0.1/2)
          ).attributes.position.array,
        lineGeometry.attributes.position.array.length * 5
      );
      positions.set(
        lineGeometry.clone()
          .applyMatrix(
            localMatrix.makeRotationFromQuaternion(localQuaternion.setFromAxisAngle(localVector.set(0, 0, 1), Math.PI/2))
          )
          .applyMatrix(
            localMatrix.makeTranslation(0, 0.1/2, -0.1/2)
          ).attributes.position.array,
        lineGeometry.attributes.position.array.length * 6
      );
      positions.set(
        lineGeometry.clone()
          .applyMatrix(
            localMatrix.makeRotationFromQuaternion(localQuaternion.setFromAxisAngle(localVector.set(0, 0, 1), Math.PI/2))
          )
          .applyMatrix(
            localMatrix.makeTranslation(0, 0.1/2, 0.1/2)
          ).attributes.position.array,
        lineGeometry.attributes.position.array.length * 7
      );
      // axis
      positions.set(
        lineGeometry.clone()
          .applyMatrix(
            localMatrix.makeRotationFromQuaternion(localQuaternion.setFromAxisAngle(localVector.set(1, 0, 0), Math.PI/2))
          )
          .applyMatrix(
            localMatrix.makeTranslation(-0.1/2, -0.1/2, 0)
          ).attributes.position.array,
        lineGeometry.attributes.position.array.length * 8
      );
      positions.set(
        lineGeometry.clone()
          .applyMatrix(
            localMatrix.makeRotationFromQuaternion(localQuaternion.setFromAxisAngle(localVector.set(1, 0, 0), Math.PI/2))
          )
          .applyMatrix(
            localMatrix.makeTranslation(-0.1/2, 0.1/2, 0)
          ).attributes.position.array,
        lineGeometry.attributes.position.array.length * 9
      );
      positions.set(
        lineGeometry.clone()
          .applyMatrix(
            localMatrix.makeRotationFromQuaternion(localQuaternion.setFromAxisAngle(localVector.set(1, 0, 0), Math.PI/2))
          )
          .applyMatrix(
            localMatrix.makeTranslation(0.1/2, -0.1/2, 0)
          ).attributes.position.array,
        lineGeometry.attributes.position.array.length * 10
      );
      positions.set(
        lineGeometry.clone()
          .applyMatrix(
            localMatrix.makeRotationFromQuaternion(localQuaternion.setFromAxisAngle(localVector.set(1, 0, 0), Math.PI/2))
          )
          .applyMatrix(
            localMatrix.makeTranslation(0.1/2, 0.1/2, 0)
          ).attributes.position.array,
        lineGeometry.attributes.position.array.length * 11
      );
      const numLinePositions = lineGeometry.attributes.position.array.length / 3;
      const indices = new Uint16Array(lineGeometry.index.array.length * 12);
      for (let i = 0; i < 12; i++) {
        indices.set(
          lineGeometry.index.array,
          lineGeometry.index.array.length * i
        );

        for (let j = 0; j < lineGeometry.index.array.length; j++) {
          lineGeometry.index.array[j] += numLinePositions;
        }
      }
      geometry.setIndex(new THREE.BufferAttribute(indices, 1));

      const _makeMesh = ({position: [x, y, z]}) => {
        const material = new THREE.MeshBasicMaterial({
          color: 0x101010,
        });
        material.polygonOffsetUnits = -10;
        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.x = x;
        mesh.position.y = y;
        mesh.position.z = z;
        mesh.rotation.x = -Math.PI / 2;
        result.add(mesh);

        return mesh;
      };

      const headMesh = _makeMesh({
        position: [0, 0.1, 0.05],
      });
      result.headMesh = headMesh;
      const pocketMeshes = [
        {
          position: [0.2, BAG_Y_OFFSET + 0.15, BAG_Z_OFFSET], // top right
        },
        {
          position: [0.2, BAG_Y_OFFSET + 0.05, BAG_Z_OFFSET],
        },
        {
          position: [0.2, BAG_Y_OFFSET - 0.05, BAG_Z_OFFSET],
        },
        {
          position: [0.2, BAG_Y_OFFSET - 0.15, BAG_Z_OFFSET], // bottom right
        },
        {
          position: [-0.2, BAG_Y_OFFSET + 0.15, BAG_Z_OFFSET], // top left
        },
        {
          position: [-0.2, BAG_Y_OFFSET + 0.05, BAG_Z_OFFSET],
        },
        {
          position: [-0.2, BAG_Y_OFFSET - 0.05, BAG_Z_OFFSET],
        },
        {
          position: [-0.2, BAG_Y_OFFSET - 0.15, BAG_Z_OFFSET], // bottom left
        },
      ].map(_makeMesh);
      result.pocketMeshes = pocketMeshes;

      const equipmentBoxMeshes = pocketMeshes.concat([headMesh/*, bodyMesh*/])/*.concat(armMeshes)*/;
      result.equipmentBoxMeshes = equipmentBoxMeshes;

      return result;
    };
    const bagMesh = _makeBagMesh();
    scene.add(bagMesh);

    const _loadEquipment = () => {
      console.log('load equipment');
      return; // XXX

      items.requestStorageFiles()
        .then(storageFiles => storageFiles.find(fileSpec => fileSpec.name === 'bag-vr-data' && fileSpec.ext === 'json'))
        .then(bagVrDataFile => {
          if (bagVrDataFile) {
            return bagVrDataFile.readAsJson();
          } else {
            return Promise.resolve(null);
          }
        })
        .then(assetsData => {
          assetsData = assetsData || [];
          for (let i = 0; i < assetsData.length; i++) {
            const assetData = assetsData[i];

            if (assetData) {
              const {id, name, ext, json, file} = assetData;
              const itemSpec = {
                assetId: _makeId(),
                id,
                name,
                ext,
                json,
                file,
                position: zeroVector.toArray().concat(zeroQuaternion.toArray()).concat(localVector.copy(oneVector).multiplyScalar(0.4).toArray()),
                owner: player.getId(),
                physics: false,
                visible: true,
                open: false,
              };
              const grabbable = items.makeItem(itemSpec); // XXX remove these on hte server side on quit via owner binding

              const equipmentBoxMesh = bagMesh.equipmentBoxMeshes[i];
              equipmentBoxMesh.add(grabbable.mesh);
              // grabbable.setState(zeroVector, zeroQuaternion, localVector.copy(oneVector).multiplyScalar(0.4));

              equipmentState.assets[i] = grabbable;
            }
          }
        });
    };
    _loadEquipment();
    const _saveEquipment = _debounce(next => {
      console.log('save equipment');
      return; // XXX

      items.requestStorageFiles()
        .then(storageFiles => {
          const bagVrDataFile = storageFiles.find(fileSpec => fileSpec.name === 'bag-vr-data' && fileSpec.ext === 'json');

          if (bagVrDataFile) {
            return Promise.resolve(bagVrDataFile);
          } else {
            return items.requestMakeStorageFile('bag-vr-data', 'json');
          }
        })
        .then(bagVrDataFile => {
          const assetsData = equipmentState.assets.map(assetInstance => {
            if (assetInstance) {
              const assetData = {
                id: assetInstance.id,
                name: assetInstance.name,
                ext: assetInstance.ext,
              };
              if (assetInstance.json) {
                assetData.json = assetInstance.json;
              }
              if (assetInstance.file) {
                assetData.file = assetInstance.file;
              }
              return assetData;
            } else {
              return null;
            }
          });
          const assetsDataJson = JSON.stringify(assetsData);
          return bagVrDataFile.write(assetsDataJson);
        })
        .then(() => {
          next();
        })
        .catch(err => {
          console.warn(err);

          next();
        });
    });

    const equipmentState = {
      assets: (() => {
        const numEquipmentBoxMeshes = bagMesh.equipmentBoxMeshes.length;
        const result = Array(numEquipmentBoxMeshes);
        for (let i = 0; i < numEquipmentBoxMeshes; i++) {
          result[i] = null;
        }
        return result;
      })()
    };
    const _makeEquipmentHoverState = () => ({
      equipmentIndex: -1,
    });
    const equipmentHoverStates = [
      _makeEquipmentHoverState(),
      _makeEquipmentHoverState(),
    ];

    /* const _gripdown = e => {
      const {side} = e;

      const equipmentHoverState = equipmentHoverStates[side];
      const {equipmentIndex} = equipmentHoverState;
      if (equipmentIndex !== -1) {
        const grabbable = equipmentState.assets[equipmentIndex];

        if (grabbable) {
          const equipmentBoxMesh = bagMesh.equipmentBoxMeshes[equipmentIndex];
          equipmentBoxMesh.remove(grabbable.mesh);
          scene.add(grabbable.mesh);

          grabbable.grab(side);
          grabbable.setOwner(null);

          equipmentState.assets[equipmentIndex] = null;
          _saveEquipment();
        }
      }
    };
    input.on('gripdown', _gripdown);

    const _release = e => {
      const {side, grabbable} = e;

      const equipmentHoverState = equipmentHoverStates[side];
      const {equipmentIndex} = equipmentHoverState;
      if (equipmentIndex !== -1) {
        const equipmentBoxMesh = bagMesh.equipmentBoxMeshes[equipmentIndex];
        equipmentBoxMesh.add(grabbable.mesh);
        grabbable.setState(zeroVector, zeroQuaternion, localVector.copy(oneVector).multiplyScalar(0.4));
        grabbable.disablePhysics();
        grabbable.setOwner(player.getId());

        equipmentState.assets[equipmentIndex] = grabbable;
        _saveEquipment();
      }
    };
    hands.on('release', _release); */

    const position = new THREE.Vector3();
    const velocity = new THREE.Vector3();
    let lastTime = Date.now();
    function animate() {
      const currentTime = Date.now();
      const timePassed = Math.max(currentTime - lastTime, 1);
      lastTime = currentTime;

      const _updateControls = () => {
        if (window.document.pointerLockElement) {
          localVector.set(0, 0, 0);
          if (keys.up) {
            localVector.z--;
          }
          if (keys.down) {
            localVector.z++;
          }
          if (keys.left) {
            localVector.x--;
          }
          if (keys.right) {
            localVector.x++;
          }
          localVector
            .normalize()
            .multiplyScalar(0.1);
          localEuler.setFromQuaternion(fakeDisplay.quaternion, localEuler.order);
          localEuler.x = 0;
          fakeDisplay.position.add(
            localVector
              .applyEuler(localEuler)
          );

          for (let i = 0; i < 2; i++) {
            const gamepad = fakeDisplay.gamepads[i];
            if (gamepad) {
              localVector.copy(fakeDisplay.position)
                .add(
                  localVector2.set(-0.1 + (i*0.1*2), -0.1, -0.2)
                    .applyQuaternion(fakeDisplay.quaternion)
                ).toArray(gamepad.pose.position);
              fakeDisplay.quaternion.toArray(fakeDisplay.gamepads[i].pose.orientation);
            }
          }

          fakeDisplay.update();
        }
      };
      const _updateControllers = () => {
        const gamepads = _getGamepads();

        for (let i = 0; i < gamepads.length; i++) {
          const gamepad = gamepads[i];
          if (gamepad) {
            const controllerMesh = controllerMeshes[i];
            controllerMesh.position.fromArray(gamepad.pose.position);
            controllerMesh.quaternion.fromArray(gamepad.pose.orientation);
            controllerMesh.updateMatrixWorld();
          }
        }
      };
      const _updateInteractions = () => {
        const gamepads = _getGamepads();

        for (let i = 0; i < gamepads.length; i++) {
          const gamepad = gamepads[i];

          if (gamepad) {
            const controllerMesh = controllerMeshes[i];

            let pressed = false;
            let grabbed = false;
            let menuPressed = false;
            if (gamepad) {
              pressed = gamepad.buttons[1].pressed;
              grabbed = gamepad.buttons[2].pressed;
              menuPressed = gamepad.buttons[3].pressed;
            }

            const lastGrabbed = lastGrabbeds[i];
            lastGrabbeds[i] = grabbed;
            if (grabbed && !lastGrabbed) {
              const objectMeshes = xrmpThree.getObjectMeshes();
              let targetObject = objectMeshes.find(objectMesh =>
                objectMesh.parent === scene && objectMesh.position.distanceTo(controllerMesh.position) < 0.1
              );
              if (!targetObject) {
                const equipmentHoverState = equipmentHoverStates[i];
                const {equipmentIndex} = equipmentHoverState;

                if (equipmentIndex !== -1) {
                  const equipmentBoxMesh = bagMesh.equipmentBoxMeshes[equipmentIndex];
                  const objectMesh = equipmentBoxMesh.children[0];
                  scene.add(objectMesh);
                  targetObject = objectMesh;
                }
              }
              if (targetObject) {
                grabbedObjects[i] = targetObject;
              }
            } else if (!grabbed && lastGrabbed) {
              const grabbedObject = grabbedObjects[i];
              if (grabbedObject) {
                grabbedObjects[i] = null;

                const equipmentHoverState = equipmentHoverStates[i];
                const {equipmentIndex} = equipmentHoverState;
                if (equipmentIndex !== -1) {
                  const equipmentBoxMesh = bagMesh.equipmentBoxMeshes[equipmentIndex];
                  grabbedObject.position.set(0, 0, 0);
                  grabbedObject.quaternion.set(0, 0, 0, 1);
                  equipmentBoxMesh.add(grabbedObject);
                  equipmentBoxMesh.updateMatrixWorld();
                }
              }
            }
          }
        }
      };
      const _updateObjects = () => {
        const gamepads = _getGamepads();
        for (let i = 0; i < 2; i++) {
          const grabbedObject = grabbedObjects[i];

          if (grabbedObject) {
            const gamepad = gamepads[i];

            grabbedObject.position.fromArray(gamepad.pose.position);
            grabbedObject.quaternion.fromArray(gamepad.pose.orientation);
            grabbedObject.updateMatrixWorld();

            if (_isMpOpen()) {
              grabbedObject.needsUpdate = true;
            }
          }
        }
      };
      const _updateMp = () => {
        if (_isMpOpen()) {
          mp.localPlayerMesh.hmd.position.copy(camera.position);
          mp.localPlayerMesh.hmd.quaternion.copy(camera.quaternion);

          for (let i = 0; i < 2; i++) {
            const controllerMesh = controllerMeshes[i];
            mp.localPlayerMesh.gamepads[i].visible = true;
            mp.localPlayerMesh.gamepads[i].position.copy(controllerMesh.position);
            mp.localPlayerMesh.gamepads[i].quaternion.copy(controllerMesh.quaternion);
          }

          mp.pushUpdate();
        }
      };
      const _updateBagMesh = () => {
        const vrCamera = renderer.vr.getCamera(camera);
        vrCamera.matrixWorld.decompose(vrCamera.position, vrCamera.quaternion, vrCamera.scale);

        bagMesh.position.copy(vrCamera.position);
        const hmdEuler = new THREE.Euler().setFromQuaternion(vrCamera.quaternion, camera.rotation.order);
        bagMesh.rotation.y = hmdEuler.y;
        bagMesh.updateMatrixWorld();
      };
      const _updateEquipmentBoxMeshes = () => {
        const {equipmentBoxMeshes} = bagMesh;
        for (let i = 0; i < 2; i++) {
          const controllerMesh = controllerMeshes[i];
          const equipmentHoverState = equipmentHoverStates[i];

          const equipmentBoxMeshSpecs = equipmentBoxMeshes.map((equipmentBoxMesh, i) => {
            const {position: equipmentBoxMeshPosition} = _decomposeObjectMatrixWorld(equipmentBoxMesh);

            return {
              index: i,
              distance: controllerMesh.position.distanceTo(equipmentBoxMeshPosition),
            };
          });
          const equipmentBoxMeshSpecsInRange = equipmentBoxMeshSpecs.filter(equipmentBoxMeshSpec => equipmentBoxMeshSpec.distance <= 0.1);

          if (equipmentBoxMeshSpecsInRange.length > 0) {
            const sortedEquipmentBoxMeshSpecs = equipmentBoxMeshSpecsInRange.sort((a, b) => a.distance - b.distance);
            const closestEquipmentBoxMeshSpec = sortedEquipmentBoxMeshSpecs[0];
            const {index: closestEquipmentBoxMeshIndex} = closestEquipmentBoxMeshSpec;

            equipmentHoverState.equipmentIndex = closestEquipmentBoxMeshIndex;
          } else {
            equipmentHoverState.equipmentIndex = -1;
          }
        }
        for (let i = 0; i < equipmentBoxMeshes.length; i++) {
          const equipmentBoxMesh = equipmentBoxMeshes[i];
          const hovered = equipmentHoverStates.some(equipmentHoverState => equipmentHoverState.equipmentIndex === i);
          equipmentBoxMesh.material.color.setHex(hovered ? 0x2196F3 : 0x101010);
          equipmentBoxMesh.material.polygonOffset = hovered;
        }
      };
      const _updateAssetInstances = () => {
        return; // XXX
        const destinationPosition = localVector.copy(camera.position)
          .add(localVector2.set(0, -1.6, 0));
        const destinationMatrix = localMatrix.compose(
          destinationPosition,
          camera.quaternion,
          oneVector
        );
        const destinationMatrixInverse = localMatrix.getInverse(destinationMatrix);

        const assetInstances = items.getAssetInstances();
        for (let i = 0; i < assetInstances.length; i++) {
          const assetInstance = assetInstances[i];
          if (!assetInstance.isGrabbed() && !assetInstance.open && !equipmentState.assets.includes(assetInstance)) {
            const diffVector = localVector2.copy(assetInstance.position)
              .applyMatrix4(destinationMatrixInverse)
              .sub(zeroVector);
            const diffScalar = Math.max(Math.abs(diffVector.x), Math.abs(diffVector.y), Math.abs(diffVector.z));
            if (diffScalar < 0.4) {
              let freeEquipmentIndex = -1;
              for (let j = 0; j < bagMesh.equipmentBoxMeshes.length; j++) {
                if (equipmentState.assets[j] === null) {
                  freeEquipmentIndex = j;
                  break;
                }
              }

              if (freeEquipmentIndex !== -1) {
                const grabbable = assetInstance;

                const equipmentBoxMesh = bagMesh.equipmentBoxMeshes[freeEquipmentIndex];
                equipmentBoxMesh.add(grabbable.mesh);
                grabbable.setState(zeroVector, zeroQuaternion, localVector.copy(oneVector).multiplyScalar(0.4));
                grabbable.disablePhysics();
                grabbable.setOwner(player.getId());

                equipmentState.assets[freeEquipmentIndex] = grabbable;
                _saveEquipment();
              }

              const note = notification.addNotification(`Picked up ${assetInstance.name}.${assetInstance.ext}`);
              setTimeout(() => {
                notification.removeNotification(note);
              }, 3000);
            }
          }
        }
      };
      _updateControls();
      _updateControllers();
      _updateInteractions();
      _updateObjects();
      _updateBagMesh();
      _updateEquipmentBoxMeshes();
      _updateAssetInstances();
      _updateMp();

      const device = renderer.vr.getDevice();
      if (device && device.constructor.name === 'FakeVRDisplay') {
        camera.position.copy(device.position);
        camera.quaternion.copy(device.quaternion);

        camera.projectionMatrix.fromArray(device._frameData.leftProjectionMatrix);

        renderer.render(scene, camera);
      } else {
        renderer.render(scene, camera);
      }

      window.requestAnimationFrame(animate);
    }
    window.requestAnimationFrame(animate);

    const _handleKey = (code, shiftKey) => {
      if (code === 8) { // backspace
        if (urlCursor > 0) {
          urlText = urlText.slice(0, urlCursor - 1) + urlText.slice(urlCursor);
          urlCursor--;
          menuMesh.urlMesh.updateText();
        }
      } else if (code === 46) { // delete
        if (urlCursor < urlText.length) {
          urlText = urlText.slice(0, urlCursor) + urlText.slice(urlCursor + 1);
          menuMesh.urlMesh.updateText();
        }
      } else if (code === 32) { // space
        urlText = urlText.slice(0, urlCursor) + ' ' + urlText.slice(urlCursor);
        urlCursor++;
        menuMesh.urlMesh.updateText();
      } else if (code === 13) { // enter
        _openUrl(urlText);
      } else if (
        code === 9 || // tab
        code === 16 || // shift
        code === 17 || // ctrl
        code === 18 || // alt
        code === 20 || // capslock
        code === 27 || // esc
        code === 91 // win
      ) {
        // nothing
      } else if (code === 37) { // left
        urlCursor = Math.max(urlCursor - 1, 0);
        menuMesh.urlMesh.updateText();
      } else if (code === 39) { // right
        urlCursor = Math.min(urlCursor + 1, urlText.length);
        menuMesh.urlMesh.updateText();
      } else if (code === 38) { // up
        urlCursor = 0;
        menuMesh.urlMesh.updateText();
      } else if (code === 40) { // down
        urlCursor = urlText.length;
        menuMesh.urlMesh.updateText();
      } else if (code === -1) {
        // nothing
      } else {
        let c = keyCode(code);
        if (shiftKey) {
          c = c.toUpperCase();
        }
        urlText = urlText.slice(0, urlCursor) + c + urlText.slice(urlCursor);
        urlCursor++;
        menuMesh.urlMesh.updateText();
      }
    };

    window.addEventListener('resize', e => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();

      const device = renderer.vr.getDevice();
      if (device === fakeDisplay) {
        renderer.vr.setDevice(null);
      }
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      if (device === fakeDisplay) {
        renderer.vr.setDevice(fakeDisplay);
      }
    });

    let displays = [];
    const _updateDisplays = () => {
      if (window.navigator.getVRDisplays) {
        window.navigator.getVRDisplays()
          .then(ds => {
            displays = ds;
          })
          .catch(err => {
            console.warn(err);
          });
      }
    };
    _updateDisplays();
    window.addEventListener('vrdisplayconnect', _updateDisplays);
    window.addEventListener('vrdisplaydisconnect', _updateDisplays);

    const audioCtx = new AudioContext({
      sampleRate: 48000,
    });
    THREE.AudioContext.setContext(audioCtx);

    const keys = {
      up: false,
      down: false,
      left: false,
      right: false,
    };
    window.addEventListener('keypress', e => {
      const _normalizeKeycode = keyCode => {
        if (keyCode >= 97 && keyCode <= 122) {
          return keyCode - 32;
        } else {
          return keyCode;
        }
      };

      switch (e.keyCode) {
        case 105: { // I
          console.log('enable VR');

          const display = displays.find(display =>
            display.constructor.name === 'VRDisplay'
          );
          if (display) {
            if (window.document.pointerLockElement) {
              window.document.exitPointerLock();
            }
            renderer.vr.setDevice(null);

            display.requestPresent([{source: canvas}])
              .then(() => {
                renderer.vr.setDevice(display);
              });
          }
          break;
        }
        case 111: { // O
          console.log('enable ML');

          const display = displays.find(display =>
            display.constructor.name === 'MLDisplay'
          );
          if (display) {
            if (window.document.pointerLockElement) {
              window.document.exitPointerLock();
            }
            renderer.vr.setDevice(null);

            display.requestPresent([{source: canvas}])
              .then(() => {
                renderer.vr.setDevice(display);

                scene.background = null;
              });
          }
          break;
        }
        case 112: { // P
          if (_isMpOpen() && !voicechatEnabled) {
            console.log('enable voicechat');

            navigator.mediaDevices.getUserMedia({
              audio: true,
            })
              .then(mediaStream => {
                mp.localPlayerMesh.setMediaStream(mediaStream);
              });

            voicechatEnabled = true;
          }
          break;
        }
      }
    });
    window.addEventListener('keydown', e => {
      if (window.document.pointerLockElement) {
        switch (e.keyCode) {
          case 87: { // W
            keys.up = true;
            if (!window.document.pointerLockElement) {
              renderer.domElement.requestPointerLock();
            }
            break;
          }
          case 83: { // S
            keys.down = true;
            if (!window.document.pointerLockElement) {
              renderer.domElement.requestPointerLock();
            }
            break;
          }
          case 65: { // A
            keys.left = true;
            if (!window.document.pointerLockElement) {
              renderer.domElement.requestPointerLock();
            }
            break;
          }
          case 68: { // D
            keys.right = true;
            if (!window.document.pointerLockElement) {
              renderer.domElement.requestPointerLock();
            }
            break;
          }
          case 69: { // E
            fakeDisplay.gamepads[1].buttons[3].pressed = true;
            break;
          }
        }
      }
    });
    window.addEventListener('keyup', e => {
      if (window.document.pointerLockElement) {
        switch (e.keyCode) {
          case 87: { // W
            keys.up = false;
            break;
          }
          case 83: { // S
            keys.down = false;
            break;
          }
          case 65: { // A
            keys.left = false;
            break;
          }
          case 68: { // D
            keys.right = false;
            break;
          }
          case 69: { // E
            fakeDisplay.gamepads[1].buttons[3].pressed = false;
            break;
          }
        }
      }
    });
    window.addEventListener('mousedown', () => {
      if (!window.document.pointerLockElement) {
        renderer.domElement.requestPointerLock();
      } else {
        const gamepad = fakeDisplay.gamepads[1];
        if (gamepad) {
          fakeDisplay.gamepads[1].buttons[1].pressed = true;
        }
      }
    });
    window.addEventListener('mouseup', () => {
      const gamepad = fakeDisplay.gamepads[1];
      if (gamepad) {
        gamepad.buttons[1].pressed = false;
      }
    });
    window.addEventListener('mousemove', e => {
      if (window.document.pointerLockElement) {
        const {movementX, movementY} = e;
        localEuler.setFromQuaternion(fakeDisplay.quaternion, localEuler.order);
        localEuler.y -= movementX * 0.01;
        localEuler.x -= movementY * 0.01;
        localEuler.x = Math.min(Math.max(localEuler.x, -Math.PI/2), Math.PI/2);
        fakeDisplay.quaternion.setFromEuler(localEuler);

        fakeDisplay.update();
      }
    });
    window.document.addEventListener('paste', e => {
      const {clipboardData} = e;
      const items = Array.from(clipboardData.items);
      const item = items.find(item => item.kind === 'string');
      if (item) {
        item.getAsString(s => {
          urlText = urlText.slice(0, urlCursor) + s + urlText.slice(urlCursor);
          urlCursor += s.length;
          menuMesh.urlMesh.updateText();
        });
      }
    });
    window.addEventListener('dragover', e => {
      e.preventDefault();
    });
    window.addEventListener('drop', e => {
      e.preventDefault();

      console.log('drop', e);
    });
  </script>
</body>
</html>
