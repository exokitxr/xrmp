<!doctype html>
<html>
<head>
  <style>
    body {
      display: flex;
      margin: 0;
      flex-direction: column;
    }
  </style>
</head>
<body>
  <canvas id=canvas></canvas>
  <script src="js/three.js"></script>
  <script src="js/vr-display.js"></script>
  <script src="js/skin.js"></script>
  <script src="js/OBJLoader.js"></script>
  <script src="../js/xrmp.js"></script>
  <script src="../js/xrmp-three.js"></script>
  <script>
    const canvas = document.getElementById('canvas');

    const getQueryVariable = variable => {
      const query = window.location.search.substring(1);
      const vars = query.split('&');
      for (let i = 0; i < vars.length; i++) {
        const pair = vars[i].split('=');
        if (decodeURIComponent(pair[0]) == variable) {
          return decodeURIComponent(pair[1]);
        }
      }
      return null;
    };

    const SIDES = ['left', 'right'];
    const FLOOR_SIZE = 20;

    (() => {
        const graphImg = new Image();
        graphImg.src = 'img/textures/graphy.png';
        graphImg.crossOrigin = 'Anonymous';
        graphImg.onload = () => {
          const floorMesh = (() => {
            const geometry = new THREE.PlaneBufferGeometry(FLOOR_SIZE, FLOOR_SIZE)
              .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(
                new THREE.Quaternion().setFromUnitVectors(
                  new THREE.Vector3(0, 0, 1),
                  new THREE.Vector3(0, 1, 0)
                )
              ));
            const uvs = geometry.attributes.uv.array;
            const numUvs = uvs.length / 2;
            for (let i = 0; i < numUvs; i++) {
              uvs[i * 2 + 0] *= FLOOR_SIZE / 10 * 2;
              uvs[i * 2 + 1] *= FLOOR_SIZE / 10;
            }

            const texture = new THREE.Texture(
              graphImg,
              THREE.UVMapping,
              THREE.RepeatWrapping,
              THREE.RepeatWrapping,
              THREE.NearestFilter,
              THREE.NearestFilter,
              THREE.RGBAFormat,
              THREE.UnsignedByteType,
              1
            );
            texture.needsUpdate = true;
            const material = new THREE.MeshBasicMaterial({
              map: texture,
              side: THREE.DoubleSide,
            });
            const mesh = new THREE.Mesh(geometry, material);
            return mesh;
          })();
          scene.add(floorMesh);
        };
        graphImg.onerror = err => {
          console.warn(err.stack);
        };
      })();

    const upVector = new THREE.Vector3(0, 1, 0);
    const armQuaternionOffset = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, -1, 0), new THREE.Vector3(0, 0, -1));

    const localVector = new THREE.Vector3();
    const localVector2 = new THREE.Vector3();
    const localVector3 = new THREE.Vector3();
    const localVector4 = new THREE.Vector3();
    const localVector5 = new THREE.Vector3();
    const localQuaternion = new THREE.Quaternion();
    const localEuler = new THREE.Euler();
    localEuler.order = 'YXZ';

    const camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.1, 10 * 1024);
    camera.position.set(0, 1, 1);
    camera.rotation.order = 'YXZ';

    const fakeDisplay = window.navigator.createVRDisplay();
    fakeDisplay.setSize(window.innerWidth * window.devicePixelRatio, window.innerHeight * window.devicePixelRatio);
    fakeDisplay.position.copy(camera.position);
    fakeDisplay.quaternion.copy(camera.quaternion);
    fakeDisplay.update();
    fakeDisplay.requestPresent([{source: canvas}])
      .then(() => {
        renderer.vr.setDevice(fakeDisplay);
      });

    const _getGamepads = () => {
      if (fakeDisplay.isPresenting) {
        return fakeDisplay.gamepads;
      } else {
        return navigator.getGamepads();
      }
    };

    let voicechatEnabled = false;
    const mp = (() => {
      const url = getQueryVariable('m');
      if (url) {
        const _makeCubeMesh = () => {
          const geometry = new THREE.BoxBufferGeometry(0.1, 0.1, 0.1);
          const material = new THREE.MeshPhongMaterial({
            color: 0xFF0000,
          });
          const mesh = new THREE.Mesh(geometry, material);
          return mesh;
        };

        const xrmp = new XRMultiplayer(url);
        const xrmpThree = new XRMultiplayerTHREE(xrmp);
        xrmpThree.localPlayerMesh = null;
        xrmpThree.onsync = () => {
          camera.add(xrmpThree.getAudioListener());

          const localPlayerMesh = xrmpThree.createLocalPlayerMesh();
          xrmpThree.localPlayerMesh = localPlayerMesh;

          const objectId = 1;
          const objectMeshes = xrmpThree.getObjectMeshes();
          const objectMesh = objectMeshes.find(objectMesh => objectMesh.object.id === objectId);
          if (!objectMesh) {
            const objectMesh = mp.createObjectMesh(objectId);

            const cubeMesh = _makeCubeMesh();
            objectMesh.add(cubeMesh);

            objectMesh.object.setUpdateExpression('[1,2,3]');

            scene.add(objectMesh);
          }
        };
        xrmpThree.onclose = () => {
          console.log('mp close');
        };
        xrmpThree.onerror = e => {
          console.warn('mp error', e.error);
        };
        xrmpThree.onplayerenter = playerMesh => {
          const skinMesh = _makeSkinMesh(playerMesh);
          playerMesh.add(skinMesh);

          scene.add(playerMesh);
        };
        xrmpThree.onplayerleave = playerMesh => {
          scene.remove(playerMesh);
        };
        xrmpThree.onobjectadd = objectMesh => {
          const cubeMesh = _makeCubeMesh();
          objectMesh.add(cubeMesh);

          scene.add(objectMesh);
        };
        xrmpThree.onobjectremove = objectMesh => {
          scene.remove(objectMesh);
        };
        return xrmpThree;
      } else {
        return null;
      }
    })();
    const _isMpOpen = () => Boolean(mp && mp.localPlayerMesh);

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    const renderer = new THREE.WebGLRenderer({
      canvas,
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.sortObjects = false;
    renderer.vr.enabled = true;

    const _makeRenderTarget = (width, height) => {
      const renderTarget = new THREE.WebGLRenderTarget(width, height);
      renderTarget.depthTexture = new THREE.DepthTexture(
        width,
        height,
        THREE.UnsignedInt248Type,
        THREE.UVMapping,
        THREE.ClampToEdgeWrapping,
        THREE.ClampToEdgeWrapping,
        THREE.NearestFilter,
        THREE.NearestFilter,
        1,
        THREE.DepthStencilFormat
      );
      return renderTarget;
    };
    let renderTarget = _makeRenderTarget(canvas.width, canvas.height);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xFFFFFF);

    const portalMeshes = [];
    const frontMeshes = [];
    const backMeshes = [];

    const ambientLight = new THREE.AmbientLight(0x808080);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xFFFFFF, 1);
    directionalLight.position.set(1, 1, 1);
    scene.add(directionalLight);

    const controllerMeshes = [null, null];
    const lastPresseds = [false, false];
    const lastMenuPresseds = [false, false];
    const lastGrabbeds = [false, false];
    const grabbedObjects = [null, null];
    for (let i = 0; i < 2; i++) {
      const controllerMesh = new THREE.Object3D();
      controllerMesh.position.set(i === 0 ? -0.1 : 0.1, 1, 0.5);
      controllerMesh.quaternion.setFromUnitVectors(
        new THREE.Vector3(0, 0, -1),
        new THREE.Vector3(0, -1, -1)
      );

      controllerMesh.ray = new THREE.Ray();
      controllerMesh.update = () => {
        controllerMesh.ray.origin.copy(controllerMesh.position);
        controllerMesh.ray.direction
          .set(0, 0, -1)
          .applyQuaternion(controllerMesh.quaternion);
      };

      scene.add(controllerMesh);
      controllerMeshes[i] = controllerMesh;
    }

    const controllerMeshLoader = new THREE.OBJLoader();
    controllerMeshLoader.setPath('models/obj/vive-controller/');
    controllerMeshLoader.load('vr_controller_vive_1_5.obj', object => {
      const textureLoader = new THREE.TextureLoader();
      textureLoader.setPath('models/obj/vive-controller/');

      const controllerMesh = object.children[0];
      controllerMesh.material.map = textureLoader.load('onepointfive_texture.png');
      controllerMesh.material.specularMap = textureLoader.load('onepointfive_spec.png');

      controllerMeshes[0].add(object.clone());
      controllerMeshes[1].add(object.clone());
    });

    const _makeSkinMesh = (() => {
      const hmdEuler = new THREE.Euler();
      const controllerPosition = new THREE.Vector3();
      const controllerQuaternion = new THREE.Quaternion();
      const playerEuler = new THREE.Euler();
      const meshWorldPosition = new THREE.Vector3();
      const meshEyeWorldPosition = new THREE.Vector3();
      const playerQuaternionInverse = new THREE.Quaternion();
      const headQuaternion = new THREE.Quaternion();
      const headQuaternionInverse = new THREE.Quaternion();
      const localUpVector = new THREE.Vector3();
      const armWorldPosition = new THREE.Vector3();
      const armQuaternion = new THREE.Quaternion();
      const armQuaternionInverse = new THREE.Quaternion();
      const rotationMatrix = new THREE.Matrix4();

      const _mod = (value, divisor) => {
        const n = value % divisor;
        return n < 0 ? (divisor + n) : n
      };
      const _angleDiff = (a, b) => _mod((b - a) + Math.PI, Math.PI * 2) - Math.PI;

      return playerMesh => {
        const mesh = skin({
          limbs: true,
        });

        const uniforms = THREE.UniformsUtils.clone(skin.SKIN_SHADER.uniforms);

        const handMeshes = Array(2);
        for (let i = 0; i < handMeshes.length; i++) {
          const handMesh = _makeHandMesh();
          scene.add(handMesh);
          handMeshes[i] = handMesh;
        }
        mesh.handMeshes = handMeshes;

        mesh.onBeforeRender = (function(onBeforeRender) {
          return function() {
            mesh.material.uniforms.headRotation.value.copy(uniforms.headRotation.value);
            mesh.material.uniforms.leftArmRotation.value.copy(uniforms.leftArmRotation.value);
            mesh.material.uniforms.rightArmRotation.value.copy(uniforms.rightArmRotation.value);
            mesh.material.uniforms.theta.value = uniforms.theta.value;
            mesh.material.uniforms.headVisible.value = uniforms.headVisible.value;
            mesh.material.uniforms.hit.value = uniforms.hit.value;

            onBeforeRender.apply(this, arguments);
          };
        })(mesh.onBeforeRender);

        playerMesh.onupdate = () => {
          hmdEuler.setFromQuaternion(playerMesh.hmd.quaternion, camera.rotation.order);
          playerEuler.setFromQuaternion(mesh.quaternion, camera.rotation.order);
          const angleDiff = _angleDiff(hmdEuler.y, playerEuler.y);
          const angleDiffAbs = Math.abs(angleDiff);
          if (angleDiffAbs > Math.PI / 2) {
            playerEuler.y += (angleDiffAbs - (Math.PI / 2)) * (angleDiff < 0 ? 1 : -1);
            mesh.quaternion.setFromEuler(playerEuler);
          }

          mesh.getWorldPosition(meshWorldPosition);
          mesh.eye.getWorldPosition(meshEyeWorldPosition);
          mesh.position.copy(playerMesh.hmd.position)
            .sub(meshEyeWorldPosition)
            .add(meshWorldPosition);

          playerQuaternionInverse.copy(mesh.quaternion).inverse();
          headQuaternion.copy(playerQuaternionInverse).multiply(playerMesh.hmd.quaternion);
          headQuaternionInverse.copy(headQuaternion).inverse();
          uniforms.headRotation.value.set(headQuaternionInverse.x, headQuaternionInverse.y, headQuaternionInverse.z, headQuaternionInverse.w);
          mesh.head.quaternion.copy(headQuaternion);
          mesh.updateMatrixWorld();

          for (let i = 0; i < 2; i++) {
            const side = SIDES[i];
            const armRotation = uniforms[side === 'left' ? 'leftArmRotation' : 'rightArmRotation'];

            if (playerMesh.gamepads[i].visible) {
              controllerPosition.copy(playerMesh.gamepads[i].position);
              controllerQuaternion.copy(playerMesh.gamepads[i].quaternion);
              localUpVector.copy(upVector).applyQuaternion(controllerQuaternion);

              mesh.arms[side].getWorldPosition(armWorldPosition);
              rotationMatrix.lookAt(
                armWorldPosition,
                controllerPosition,
                localUpVector
              );
              armQuaternion
                .setFromRotationMatrix(rotationMatrix)
                .multiply(armQuaternionOffset)
                .premultiply(playerQuaternionInverse);
              armQuaternionInverse.copy(armQuaternion).inverse();
              armRotation.value.set(armQuaternionInverse.x, armQuaternionInverse.y, armQuaternionInverse.z, armQuaternionInverse.w);
            } else {
              armRotation.value.set(0, 0, 0, 1);
            }
          }

          /* for (let i = 0; i < handMeshes.length; i++) { // XXX
            handMeshes[i].updatePlayerMatrix(playerMatrix.hands[i]);
          } */
        };

        const skinImg = new Image();
        skinImg.crossOrigin = 'Anonymous';
        skinImg.src = 'img/skins/male.png';
        skinImg.onload = () => {
          mesh.setImage(skinImg);
        };
        skinImg.onerror = err => {
          console.warn('skin image error', err.stack);
        };

        return mesh;
      };
    })();

    const position = new THREE.Vector3();
    const velocity = new THREE.Vector3();
    let lastTime = Date.now();
    function animate() {
      const currentTime = Date.now();
      const timePassed = Math.max(currentTime - lastTime, 1);
      lastTime = currentTime;

      const _updateControls = () => {
        if (window.document.pointerLockElement) {
          localVector.set(0, 0, 0);
          if (keys.up) {
            localVector.z--;
          }
          if (keys.down) {
            localVector.z++;
          }
          if (keys.left) {
            localVector.x--;
          }
          if (keys.right) {
            localVector.x++;
          }
          localVector
            .normalize()
            .multiplyScalar(0.1);
          localEuler.setFromQuaternion(fakeDisplay.quaternion, localEuler.order);
          localEuler.x = 0;
          fakeDisplay.position.add(
            localVector
              .applyEuler(localEuler)
          );

          for (let i = 0; i < 2; i++) {
            const gamepad = fakeDisplay.gamepads[i];
            if (gamepad) {
              localVector.copy(fakeDisplay.position)
                .add(
                  localVector2.set(-0.1 + (i*0.1*2), -0.1, -0.2)
                    .applyQuaternion(fakeDisplay.quaternion)
                ).toArray(gamepad.pose.position);
              fakeDisplay.quaternion.toArray(fakeDisplay.gamepads[i].pose.orientation);
            }
          }

          fakeDisplay.update();
        }
      };
      const _updateControllers = () => {
        const gamepads = _getGamepads();

        for (let i = 0; i < gamepads.length; i++) {
          const gamepad = gamepads[i];
          if (gamepad) {
            const controllerMesh = controllerMeshes[i];
            controllerMesh.position.fromArray(gamepad.pose.position);
            controllerMesh.quaternion.fromArray(gamepad.pose.orientation);
            controllerMesh.updateMatrixWorld();
          }
        }
      };
      const _updateObjects = () => {
        const gamepads = _getGamepads();
        for (let i = 0; i < 2; i++) {
          const grabbedObject = grabbedObjects[i];

          if (grabbedObject) {
            const gamepad = gamepads[i];

            grabbedObject.position.fromArray(gamepad.pose.position);
            grabbedObject.quaternion.fromArray(gamepad.pose.orientation);
            grabbedObject.updateMatrixWorld();

            if (_isMpOpen()) {
              objectMesh.position.toArray(objectMesh.object.objectMatrix.position);
              objectMesh.quaternion.toArray(objectMesh.object.objectMatrix.quaternion);

              objectMesh.object.pushUpdate();
            }
          }
        }
      };
      const _updateMp = () => {
        if (_isMpOpen()) {
          mp.localPlayerMesh.hmd.position.copy(camera.position);
          mp.localPlayerMesh.hmd.quaternion.copy(camera.quaternion);

          for (let i = 0; i < 2; i++) {
            const controllerMesh = controllerMeshes[i];
            mp.localPlayerMesh.gamepads[i].visible = true;
            mp.localPlayerMesh.gamepads[i].position.copy(controllerMesh.position);
            mp.localPlayerMesh.gamepads[i].quaternion.copy(controllerMesh.quaternion);
          }

          /* for (let i = 0; i < 2; i++) { // XXX
            mp.localPlayer.playerMatrix.hands[i].enabled[0] = +handMeshes[i].visible;
            mp.localPlayer.playerMatrix.hands[i].data.set(handMeshes[i].handFrameData);
          } */

          mp.pushUpdate();
        }
      };
      _updateControls();
      _updateControllers();
      _updateObjects();
      _updateMp();

      const device = renderer.vr.getDevice();
      if (device && device.constructor.name === 'FakeVRDisplay') {
        camera.position.copy(device.position);
        camera.quaternion.copy(device.quaternion);

        camera.projectionMatrix.fromArray(device._frameData.leftProjectionMatrix);

        renderer.render(scene, camera);
      } else {
        renderer.render(scene, camera);
      }

      window.requestAnimationFrame(animate);
    }
    window.requestAnimationFrame(animate);

    const _handleKey = (code, shiftKey) => {
      if (code === 8) { // backspace
        if (urlCursor > 0) {
          urlText = urlText.slice(0, urlCursor - 1) + urlText.slice(urlCursor);
          urlCursor--;
          menuMesh.urlMesh.updateText();
        }
      } else if (code === 46) { // delete
        if (urlCursor < urlText.length) {
          urlText = urlText.slice(0, urlCursor) + urlText.slice(urlCursor + 1);
          menuMesh.urlMesh.updateText();
        }
      } else if (code === 32) { // space
        urlText = urlText.slice(0, urlCursor) + ' ' + urlText.slice(urlCursor);
        urlCursor++;
        menuMesh.urlMesh.updateText();
      } else if (code === 13) { // enter
        _openUrl(urlText);
      } else if (
        code === 9 || // tab
        code === 16 || // shift
        code === 17 || // ctrl
        code === 18 || // alt
        code === 20 || // capslock
        code === 27 || // esc
        code === 91 // win
      ) {
        // nothing
      } else if (code === 37) { // left
        urlCursor = Math.max(urlCursor - 1, 0);
        menuMesh.urlMesh.updateText();
      } else if (code === 39) { // right
        urlCursor = Math.min(urlCursor + 1, urlText.length);
        menuMesh.urlMesh.updateText();
      } else if (code === 38) { // up
        urlCursor = 0;
        menuMesh.urlMesh.updateText();
      } else if (code === 40) { // down
        urlCursor = urlText.length;
        menuMesh.urlMesh.updateText();
      } else if (code === -1) {
        // nothing
      } else {
        let c = keyCode(code);
        if (shiftKey) {
          c = c.toUpperCase();
        }
        urlText = urlText.slice(0, urlCursor) + c + urlText.slice(urlCursor);
        urlCursor++;
        menuMesh.urlMesh.updateText();
      }
    };
    const _openUrl = (u, index = -1, cb = null) => {
      const iframe = document.createElement('iframe');
      iframe.src = u;
      iframe.hidden = true;
      iframe.index = index;
      iframe.addEventListener('framebuffer', framebuffer => {
        screenQuad.material.uniforms.numTextures.value = 2;

        const colorTexture = new THREE.Texture();
        const colorProperties = renderer.properties.get(colorTexture);
        colorProperties.__webglTexture = framebuffer.colorTexture;
        colorProperties.__webglInit = true;
        screenQuad.material.uniforms.uTexture2.value = colorTexture;

        const depthTexture = new THREE.Texture();
        const depthProperties = renderer.properties.get(depthTexture);
        depthProperties.__webglTexture = framebuffer.depthStencilTexture;
        depthProperties.__webglInit = true;
        screenQuad.material.uniforms.uDepth2.value = depthTexture;

        if (cb) {
          cb(framebuffer);
        }
      });
      iframe.addEventListener('destroy', () => {
        screenQuad.material.uniforms.numTextures.value = 1;

        const frontMesh = frontMeshes[index];
        const texture = frontMesh.material.map;

        const properties = renderer.properties.get(texture);
        properties.__webglTexture = null;
        properties.__webglInit = false;

        frontMesh.updateTab();
      });
      container.appendChild(iframe);
    };

    window.addEventListener('resize', e => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();

      const device = renderer.vr.getDevice();
      if (device === fakeDisplay) {
        renderer.vr.setDevice(null);
      }
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      if (device === fakeDisplay) {
        renderer.vr.setDevice(fakeDisplay);
      }
    });

    let displays = [];
    const _updateDisplays = () => {
      if (window.navigator.getVRDisplays) {
        window.navigator.getVRDisplays()
          .then(ds => {
            displays = ds;
          })
          .catch(err => {
            console.warn(err);
          });
      }
    };
    _updateDisplays();
    window.addEventListener('vrdisplayconnect', _updateDisplays);
    window.addEventListener('vrdisplaydisconnect', _updateDisplays);

    const audioCtx = new AudioContext({
      sampleRate: 48000,
    });
    THREE.AudioContext.setContext(audioCtx);

    const keys = {
      up: false,
      down: false,
      left: false,
      right: false,
    };
    window.addEventListener('keypress', e => {
      const _normalizeKeycode = keyCode => {
        if (keyCode >= 97 && keyCode <= 122) {
          return keyCode - 32;
        } else {
          return keyCode;
        }
      };

      if (!window.document.pointerLockElement) {
        switch (e.keyCode) {
          case 99: { // C
            if (e.ctrlKey) {
              document.execCommand('copy');
            } else {
              _handleKey(_normalizeKeycode(e.keyCode), e.shiftKey);
            }
            break;
          }
          case 118: { // V
            if (e.ctrlKey) {
              document.execCommand('paste');
            } else {
              _handleKey(_normalizeKeycode(e.keyCode), e.shiftKey);
            }
            break;
          }
          default: {
            _handleKey(_normalizeKeycode(e.keyCode), e.shiftKey);
            break;
          }
        }
      } else {
        switch (e.keyCode) {
          case 105: { // I
            console.log('enable VR');

            const display = displays.find(display =>
              display.constructor.name === 'VRDisplay'
            );
            if (display) {
              if (window.document.pointerLockElement) {
                window.document.exitPointerLock();
              }
              renderer.vr.setDevice(null);

              display.requestPresent([{source: canvas}])
                .then(() => {
                  renderer.vr.setDevice(display);
                });
            }
            break;
          }
          case 111: { // O
            console.log('enable ML');

            const display = displays.find(display =>
              display.constructor.name === 'MLDisplay'
            );
            if (display) {
              if (window.document.pointerLockElement) {
                window.document.exitPointerLock();
              }
              renderer.vr.setDevice(null);

              display.requestPresent([{source: canvas}])
                .then(() => {
                  renderer.vr.setDevice(display);

                  scene.background = null;
                });
            }
            break;
          }
          case 112: { // P
            if (_isMpOpen() && !voicechatEnabled) {
              console.log('enable voicechat');

              navigator.mediaDevices.getUserMedia({
                audio: true,
              })
                .then(mediaStream => {
                  mp.localPlayerMesh.setMediaStream(mediaStream);
                });

              voicechatEnabled = true;
            }
            break;
          }
        }
      }
    });
    window.addEventListener('keydown', e => {
      if (window.document.pointerLockElement) {
        switch (e.keyCode) {
          case 87: { // W
            keys.up = true;
            if (!window.document.pointerLockElement) {
              renderer.domElement.requestPointerLock();
            }
            break;
          }
          case 83: { // S
            keys.down = true;
            if (!window.document.pointerLockElement) {
              renderer.domElement.requestPointerLock();
            }
            break;
          }
          case 65: { // A
            keys.left = true;
            if (!window.document.pointerLockElement) {
              renderer.domElement.requestPointerLock();
            }
            break;
          }
          case 68: { // D
            keys.right = true;
            if (!window.document.pointerLockElement) {
              renderer.domElement.requestPointerLock();
            }
            break;
          }
          case 69: { // E
            fakeDisplay.gamepads[1].buttons[3].pressed = true;
            break;
          }
        }
      }
    });
    window.addEventListener('keyup', e => {
      if (window.document.pointerLockElement) {
        switch (e.keyCode) {
          case 87: { // W
            keys.up = false;
            break;
          }
          case 83: { // S
            keys.down = false;
            break;
          }
          case 65: { // A
            keys.left = false;
            break;
          }
          case 68: { // D
            keys.right = false;
            break;
          }
          case 69: { // E
            fakeDisplay.gamepads[1].buttons[3].pressed = false;
            break;
          }
        }
      }
    });
    window.addEventListener('mousedown', () => {
      if (!window.document.pointerLockElement) {
        renderer.domElement.requestPointerLock();
      } else {
        const gamepad = fakeDisplay.gamepads[1];
        if (gamepad) {
          fakeDisplay.gamepads[1].buttons[1].pressed = true;
        }
      }
    });
    window.addEventListener('mouseup', () => {
      const gamepad = fakeDisplay.gamepads[1];
      if (gamepad) {
        gamepad.buttons[1].pressed = false;
      }
    });
    window.addEventListener('mousemove', e => {
      if (window.document.pointerLockElement) {
        const {movementX, movementY} = e;
        localEuler.setFromQuaternion(fakeDisplay.quaternion, localEuler.order);
        localEuler.y -= movementX * 0.01;
        localEuler.x -= movementY * 0.01;
        localEuler.x = Math.min(Math.max(localEuler.x, -Math.PI/2), Math.PI/2);
        fakeDisplay.quaternion.setFromEuler(localEuler);

        fakeDisplay.update();
      }
    });
    window.document.addEventListener('paste', e => {
      const {clipboardData} = e;
      const items = Array.from(clipboardData.items);
      const item = items.find(item => item.kind === 'string');
      if (item) {
        item.getAsString(s => {
          urlText = urlText.slice(0, urlCursor) + s + urlText.slice(urlCursor);
          urlCursor += s.length;
          menuMesh.urlMesh.updateText();
        });
      }
    });
    window.addEventListener('dragover', e => {
      e.preventDefault();
    });
    window.addEventListener('drop', e => {
      e.preventDefault();

      console.log('drop', e);
    });
  </script>
</body>
</html>
